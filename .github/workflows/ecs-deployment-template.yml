name: Reusable ECS Task + Service Deployment

on:
  workflow_call:
    inputs:
      service-name:
        description: "ECS Service Name"
        required: false
        type: string
      task-family:
        description: "Task Definition Family"
        required: false
        type: string
      container-name:
        description: "Container Name"
        required: false
        type: string
      desired-count:
        description: "Number of tasks"
        required: false
        type: string
        default: "1"
      cpu:
        description: "Task CPU Units"
        required: false
        type: string
        default: "256"
      memory:
        description: "Task Memory (MiB)"
        required: false
        type: string
        default: "512"
      image-tag:
        description: "ECR image tag (commit SHA or latest)"
        required: false
        type: string
      environment:
        description: "Deployment environment (dev, qa, prod)"
        required: true
        type: string
        default: 'dev'
      app-language:
        description: "Application app-language (csharp, java, node, python)"
        required: true
        type: string
      extra-env:
        description: "Extra environment variables as JSON array, e.g., [{\"name\":\"DB_URL\",\"value\":\"xyz\"}]"
        required: false
        type: string
        default: '[]'

jobs:
  ecs-deploy:
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}

    permissions:
      id-token: write
      contents: read

    steps:
      # 1Ô∏è‚É£ Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNTID }}:role/GitHubActionsECSDeployRole
          aws-region: us-east-2
          audience: sts.amazonaws.com

      # 2Ô∏è‚É£ Generate Task Definition with dynamic env vars
      - name: Generate ECS Task Definition
        id: generate-taskdef
        run: |
          set -euo pipefail

          REPO_NAME=$(basename $GITHUB_REPOSITORY)       # get repo name only
          BRANCH_NAME=$GITHUB_REF_NAME                   # branch name
          SHORT_SHA=${GITHUB_SHA::7}                     # first 7 chars of SHA
          IMAGE_TAG="${INPUT_IMAGE_TAG:-${REPO_NAME}-${SHORT_SHA}}"

          ECR_IMAGE="${{ vars.AWS_ACCOUNTID }}.dkr.ecr.us-east-2.amazonaws.com/${{ vars.AWS_ECR_REPO }}:${IMAGE_TAG}"
          APP_LANGUAGE="${{ inputs.app-language }}"
          ENVIRONMENT="${{ inputs.environment }}"
          EXTRA_ENV="${{ inputs.extra-env }}"
          # Default SERVICE_NAME, TASK_FAMILY, CONTAINER_NAME to repo name if user input is empty
          SERVICE_NAME="${INPUT_SERVICE_NAME:-$(basename $GITHUB_REPOSITORY)}"
          TASK_FAMILY="${INPUT_TASK_FAMILY:-${SERVICE_NAME}-task}"
          CONTAINER_NAME="${INPUT_CONTAINER_NAME:-${SERVICE_NAME}-container}"

          # Base env variables from caller
          ENV_VARS=$(jq -n \
            --arg lang "$APP_LANGUAGE" \
            --arg env "$ENVIRONMENT" \
            '[{"name":"APP_LANGUAGE","value":$lang}, {"name":"ENVIRONMENT","value":$env}, {"name":"PORT","value":"8080"}]')
          
          echo "User Input Values"
          echo "Environment Variables - $ENV_VARS"
          echo "Image Tag - $ECR_IMAGE"
          echo "Application Language - $APP_LANGUAGE"
          echo "Environment - $ENVIRONMENT"
          echo "Extra Environment Variable - $EXTRA_ENV"

          # Add language-specific environment variables
          case "$APP_LANGUAGE" in
            csharp)
              ENV_VARS=$(echo "$ENV_VARS" | jq '[.[]] + [
                {"name":"DOTNET_RUNNING_IN_CONTAINER","value":"true"},
                {"name":"DOTNET_USE_POLLING_FILE_WATCHER","value":"true"},
                {"name":"DOTNET_SKIP_FIRST_TIME_EXPERIENCE","value":"true"},
                {"name":"DOTNET_NOLOGO","value":"true"},
                {"name":"DOTNET_SYSTEM_GLOBALIZATION_INVARIANT","value":"true"},
                {"name":"ASPNETCORE_URLS","value":"http://+:8080"}
              ]')
              ;;
            java)
              ENV_VARS=$(echo "$ENV_VARS" | jq '[.[]] + [
                {"name":"JAVA_TOOL_OPTIONS","value":"-Dfile.encoding=UTF-8"}
              ]')
              ;;
            node)
              ENV_VARS=$(echo "$ENV_VARS" | jq '[.[]] + [{"name":"NODE_ENV","value":"production"}]')
              ;;
            python)
              ENV_VARS=$(echo "$ENV_VARS" | jq '[.[]] + [{"name":"PYTHONUNBUFFERED","value":"1"}]')
              ;;
          esac

          # Merge extra environment variables safely
          if [ -n "$EXTRA_ENV" ] && [ "$EXTRA_ENV" != "[]" ]; then
            # Validate JSON first
            echo "$EXTRA_ENV" | jq . >/dev/null 2>&1 || { echo "‚ùå ERROR: extra-env is invalid JSON"; exit 1; }
            ENV_VARS=$(echo "$ENV_VARS" | jq --argjson extra "$EXTRA_ENV" '. + $extra')
          fi

          echo "‚úÖ Final environment variables:"
          echo "$ENV_VARS"

          # Generate task definition JSON
          cat <<EOF > task-def.json
          {
            "family": "$TASK_FAMILY",
            "networkMode": "awsvpc",
            "executionRoleArn": "arn:aws:iam::${{ vars.AWS_ACCOUNTID }}:role/ecsTaskExecutionRole",
            "containerDefinitions": [
              {
                "name": "$CONTAINER_NAME",
                "image": "$ECR_IMAGE",
                "portMappings": [{"containerPort":8080,"protocol":"tcp"}],
                "essential": true,
                "environment": $ENV_VARS,
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/$TASK_FAMILY",
                    "awslogs-region": "us-east-2",
                    "awslogs-stream-prefix": "ecs"
                  }
                }
              }
            ],
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "${{ inputs.cpu }}",
            "memory": "${{ inputs.memory }}"
          }
          EOF

      # 3Ô∏è‚É£ Register ECS Task Definition
      - name: Register ECS Task Definition
        run: |
          aws ecs register-task-definition --cli-input-json file://task-def.json

      # 4Ô∏è‚É£ Create or Update ECS Service
      - name: Create or Update ECS Service ${{ inputs.environment }}
        run: |
          CLUSTER_NAME=${{ vars.AWS_CLUSTER_NAME }}

          DESIRED_COUNT=${{ inputs.desired-count }}

          # Default SERVICE_NAME, TASK_FAMILY, CONTAINER_NAME to repo name if user input is empty
          SERVICE_NAME="${INPUT_SERVICE_NAME:-$(basename $GITHUB_REPOSITORY)}"
          TASK_FAMILY="${INPUT_TASK_FAMILY:-${SERVICE_NAME}-task}"
          CONTAINER_NAME="${INPUT_CONTAINER_NAME:-${SERVICE_NAME}-container}"

          # Convert GitHub vars into proper JSON arrays
          SUBNETS_JSON=$(echo "${{ vars.AWS_SUBNETS }}" | jq -R 'split(",")')
          SGS_JSON=$(echo "${{ vars.AWS_SECURITY_GROUPS }}" | jq -R 'split(",")')

          if aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" --query 'services[0].status' --output text | grep -q "ACTIVE"; then
            echo "Updating existing ECS service..."
            aws ecs update-service \
              --cluster "$CLUSTER_NAME" \
              --service "$SERVICE_NAME" \
              --task-definition "$TASK_FAMILY" \
              --desired-count "$DESIRED_COUNT" \
              --force-new-deployment
          else
            echo "Creating new ECS service..."
            aws ecs create-service \
              --cluster "$CLUSTER_NAME" \
              --service-name "$SERVICE_NAME" \
              --task-definition "$TASK_FAMILY" \
              --desired-count "$DESIRED_COUNT" \
              --launch-type FARGATE \
              --network-configuration "{
                \"awsvpcConfiguration\": {
                  \"subnets\": $SUBNETS_JSON,
                  \"securityGroups\": $SGS_JSON,
                  \"assignPublicIp\": \"ENABLED\"
                }
              }"
          fi

          echo "‚è≥ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster "$CLUSTER_NAME" \
            --services "$SERVICE_NAME"
          echo "‚úÖ ECS service is stable"
      
      # 5Ô∏è‚É£ üßπ Cleanup old ECS task definitions (keep last 5, skip active ones)
      - name: Cleanup old ECS Task Definitions
        if: always()
        run: |
          set -euo pipefail

          SERVICE_NAME="${INPUT_SERVICE_NAME:-$(basename $GITHUB_REPOSITORY)}"
          TASK_FAMILY="${INPUT_TASK_FAMILY:-${SERVICE_NAME}-task}"
          CLUSTER_NAME=${{ vars.AWS_CLUSTER_NAME }}
          KEEP_LAST=5

          echo "üîç Fetching task definitions for family: $TASK_FAMILY..."

          # Get all revisions sorted from oldest to newest
          REVISIONS=$(aws ecs list-task-definitions \
              --family-prefix "$TASK_FAMILY" \
              --sort ASC \
              --query 'taskDefinitionArns' \
              --output text)

          TOTAL=$(echo $REVISIONS | wc -w)
          DELETE_COUNT=$((TOTAL - KEEP_LAST))

          if [ $DELETE_COUNT -le 0 ]; then
              echo "‚úÖ Nothing to delete. Total revisions: $TOTAL"
              exit 0
          fi

          # Find task definitions in use by any active services in the cluster
          ACTIVE_IN_USE=$(aws ecs list-services --cluster "$CLUSTER_NAME" \
              --query 'serviceArns' --output text \
              | xargs -n1 -I {} aws ecs describe-services --cluster "$CLUSTER_NAME" --services {} \
              --query 'services[].taskDefinition' --output text | sort -u)

          echo "üîé Active task definitions in use by services:"
          echo "$ACTIVE_IN_USE" | sed 's/^/   - /'

          # Revisions to attempt deletion
          TO_DELETE=$(echo $REVISIONS | awk -v c=$DELETE_COUNT '{for(i=1;i<=c;i++) print $i}')
          KEPT=()

          echo "üóëÔ∏è Checking and deleting old task definition revisions..."
          for rev in $TO_DELETE; do
              if echo "$ACTIVE_IN_USE" | grep -qx "$rev"; then
                  echo "‚è≠Ô∏è Skipping $rev (still in use by one or more services)"
                  KEPT+=("$rev")
              else
                  echo "Deleting $rev"
                  aws ecs deregister-task-definition --task-definition "$rev"
              fi
          done

          # Add the remaining last $KEEP_LAST revisions to KEPT
          REMAINING=$(echo $REVISIONS | awk -v c=$DELETE_COUNT '{for(i=c+1;i<=NF;i++) print $i}')
          for r in $REMAINING; do KEPT+=("$r"); done

          echo "‚úÖ Cleanup complete. Kept last $KEEP_LAST revisions, skipped active ones:"
          for r in "${KEPT[@]}"; do
              echo "   - $r"
          done
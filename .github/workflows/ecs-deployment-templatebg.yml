name: Reusable ECS Task + Service Deployment (Blue-Green)

on:
  workflow_call:
    inputs:
      service-name:
        description: "ECS Service Name"
        required: false
        type: string
      task-family:
        description: "Task Definition Family"
        required: false
        type: string
      container-name:
        description: "Container Name"
        required: false
        type: string
      desired-count:
        description: "Number of tasks"
        required: false
        type: string
        default: "1"
      cpu:
        description: "Task CPU Units"
        required: false
        type: string
        default: "256"
      memory:
        description: "Task Memory (MiB)"
        required: false
        type: string
        default: "512"
      image-tag:
        description: "ECR image tag (commit SHA or latest)"
        required: false
        type: string
      environment:
        description: "Deployment environment (dev, qa, prod)"
        required: true
        type: string
        default: 'dev'
      app-language:
        description: "Application app-language (csharp, java, node, python)"
        required: true
        type: string
      extra-env:
        description: "Extra environment variables as JSON array, e.g., [{\"name\":\"DB_URL\",\"value\":\"xyz\"}]"
        required: false
        type: string
        default: '[]'
      blue-target-group:
        description: "Blue Target Group ARN"
        required: true
        type: string
      green-target-group:
        description: "Green Target Group ARN"
        required: true
        type: string
      alb-arn:
        description: "Application Load Balancer ARN"
        required: true
        type: string
      main-listener-arn:
        description: "ALB Main Listener ARN (port 80/443)"
        required: true
        type: string
      use-temp-listener:
        description: "Enable temporary listener testing before flipping traffic"
        required: false
        type: boolean
        default: true
      temp-listener-port:
        description: "Port for temporary listener (testing idle color)"
        required: false
        type: string
        default: "8081"
      auto-flip:
        description: "Automatically flip traffic to new version after testing"
        required: false
        type: boolean
        default: false

jobs:
  ecs-deploy:
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}

    permissions:
      id-token: write
      contents: read

    steps:
      # 1Ô∏è‚É£ Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ vars.AWS_ACCOUNTID }}:role/GitHubActionsECSDeployRole
          aws-region: us-east-2
          audience: sts.amazonaws.com

      # 2Ô∏è‚É£ Generate ECS Task Definition (same as your original)
      - name: Generate ECS Task Definition
        id: generate-taskdef
        run: |
          # ... (same as your current task-def generation) ...

      # 3Ô∏è‚É£ Register ECS Task Definition
      - name: Register ECS Task Definition
        run: |
          aws ecs register-task-definition --cli-input-json file://task-def.json

      # 4Ô∏è‚É£ Determine idle color and target group
      - name: Determine idle color
        id: color
        run: |
          ACTIVE_TG=$(aws elbv2 describe-listeners \
            --listener-arn ${{ inputs.main-listener-arn }} \
            --query 'Listeners[0].DefaultActions[0].TargetGroupArn' --output text)

          if [ "$ACTIVE_TG" == "${{ inputs.blue-target-group }}" ]; then
            echo "ACTIVE_COLOR=blue" >> $GITHUB_OUTPUT
            echo "IDLE_COLOR=green" >> $GITHUB_OUTPUT
            echo "IDLE_TG=${{ inputs.green-target-group }}" >> $GITHUB_OUTPUT
          else
            echo "ACTIVE_COLOR=green" >> $GITHUB_OUTPUT
            echo "IDLE_COLOR=blue" >> $GITHUB_OUTPUT
            echo "IDLE_TG=${{ inputs.blue-target-group }}" >> $GITHUB_OUTPUT
          fi
          echo "Active color: $ACTIVE_COLOR, Idle color: $IDLE_COLOR"

      # 5Ô∏è‚É£ Create or update ECS service for idle color
      - name: Deploy to idle color ECS service
        run: |
          CLUSTER_NAME=${{ vars.AWS_CLUSTER_NAME }}
          DESIRED_COUNT=${{ inputs.desired-count }}
          SERVICE_NAME="${INPUT_SERVICE_NAME:-$(basename $GITHUB_REPOSITORY)}-${{ steps.color.outputs.IDLE_COLOR }}"
          TASK_FAMILY="${INPUT_TASK_FAMILY:-${SERVICE_NAME}-task}"
          CONTAINER_NAME="${INPUT_CONTAINER_NAME:-${SERVICE_NAME}-container}"

          SUBNETS_JSON=$(echo "${{ vars.AWS_SUBNETS }}" | jq -R 'split(",")')
          SGS_JSON=$(echo "${{ vars.AWS_SECURITY_GROUPS }}" | jq -R 'split(",")')

          if aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME" --query 'services[0].status' --output text | grep -q "ACTIVE"; then
            echo "Updating existing ECS service..."
            aws ecs update-service \
              --cluster "$CLUSTER_NAME" \
              --service "$SERVICE_NAME" \
              --task-definition "$TASK_FAMILY" \
              --desired-count "$DESIRED_COUNT" \
              --force-new-deployment
          else
            echo "Creating new ECS service..."
            aws ecs create-service \
              --cluster "$CLUSTER_NAME" \
              --service-name "$SERVICE_NAME" \
              --task-definition "$TASK_FAMILY" \
              --desired-count "$DESIRED_COUNT" \
              --launch-type FARGATE \
              --network-configuration "{
                \"awsvpcConfiguration\": {
                  \"subnets\": $SUBNETS_JSON,
                  \"securityGroups\": $SGS_JSON,
                  \"assignPublicIp\": \"ENABLED\"
                }
              }"
          fi

      # 6Ô∏è‚É£ Wait for ECS service to stabilize
      - name: Wait for idle color ECS service to stabilize
        run: |
          CLUSTER_NAME=${{ vars.AWS_CLUSTER_NAME }}
          SERVICE_NAME="${INPUT_SERVICE_NAME:-$(basename $GITHUB_REPOSITORY)}-${{ steps.color.outputs.IDLE_COLOR }}"
          echo "‚è≥ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable --cluster "$CLUSTER_NAME" --services "$SERVICE_NAME"
          echo "‚úÖ ECS service for idle color is stable"

      # 7Ô∏è‚É£ Check Target Group Health
      - name: Validate Target Group health
        run: |
          IDLE_TG=${{ steps.color.outputs.IDLE_TG }}
          echo "Checking target health for idle color TG: $IDLE_TG"
          aws elbv2 describe-target-health --target-group-arn $IDLE_TG

      # 8Ô∏è‚É£ Temporary Listener Test (Optional)
      - name: Temporary Listener Test
        if: ${{ inputs.use-temp-listener }}
        id: temp_listener
        run: |
          IDLE_TG=${{ steps.color.outputs.IDLE_TG }}
          TEMP_PORT=${{ inputs.temp-listener-port }}
          ALB_ARN=${{ inputs.alb-arn }}

          # Create temporary listener
          TEMP_LISTENER_ARN=$(aws elbv2 create-listener \
            --load-balancer-arn $ALB_ARN \
            --protocol HTTP \
            --port $TEMP_PORT \
            --default-actions Type=forward,TargetGroupArn=$IDLE_TG \
            --query 'Listeners[0].ListenerArn' --output text)
          echo "TEMP_LISTENER_ARN=$TEMP_LISTENER_ARN" >> $GITHUB_OUTPUT

          echo "‚úÖ Temporary listener created. Test at http://<ALB_DNS>:$TEMP_PORT"

      # 9Ô∏è‚É£ Delete temporary listener after testing
      - name: Remove Temporary Listener
        if: ${{ inputs.use-temp-listener }}
        run: |
          if [ -n "${{ steps.temp_listener.outputs.TEMP_LISTENER_ARN }}" ]; then
            aws elbv2 delete-listener --listener-arn ${{ steps.temp_listener.outputs.TEMP_LISTENER_ARN }}
            echo "‚úÖ Temporary listener removed."
          fi

      # üîü Manual Flip Step (Idle ‚Üí Active)
      - name: Flip Traffic to Idle Color (Auto)
        if: ${{ inputs.auto-flip == 'true' }}
        run: |
          IDLE_TG=${{ steps.color.outputs.IDLE_TG }}
          LISTENER_ARN=${{ inputs.main-listener-arn }}

          echo "Flipping traffic to new color..."
          aws elbv2 modify-listener \
            --listener-arn $LISTENER_ARN \
            --default-actions Type=forward,TargetGroupArn=$IDLE_TG

          echo "‚úÖ Traffic successfully flipped to idle color."

      #  üßπ Cleanup old ECS task definitions (keep last 5, skip active ones)
      - name: Cleanup old ECS Task Definitions
        if: always()
        run: |
          set -euo pipefail

          # Color codes
          YELLOW='\033[1;33m'
          GREEN='\033[1;32m'
          NC='\033[0m' # No Color

          SERVICE_NAME="${INPUT_SERVICE_NAME:-$(basename $GITHUB_REPOSITORY)}"
          TASK_FAMILY="${INPUT_TASK_FAMILY:-${SERVICE_NAME}-task}"
          CLUSTER_NAME=${{ vars.AWS_CLUSTER_NAME }}
          KEEP_LAST=5

          echo -e "üîç Fetching task definitions for family: ${YELLOW}$TASK_FAMILY${NC}..."

          # Get all revisions sorted from oldest to newest
          REVISIONS=$(aws ecs list-task-definitions \
              --family-prefix "$TASK_FAMILY" \
              --sort ASC \
              --query 'taskDefinitionArns' \
              --output text)

          TOTAL=$(echo $REVISIONS | wc -w)
          DELETE_COUNT=$((TOTAL - KEEP_LAST))

          if [ $DELETE_COUNT -le 0 ]; then
              echo -e "‚úÖ Nothing to delete. Total revisions: ${GREEN}$TOTAL${NC}"
              exit 0
          fi

          # Find task definitions in use by any active services in the cluster, but only for this task family
          ACTIVE_IN_USE=()
          for svc in $(aws ecs list-services --cluster "$CLUSTER_NAME" --query 'serviceArns' --output text); do
              td=$(aws ecs describe-services --cluster "$CLUSTER_NAME" --services "$svc" \
                  --query 'services[].taskDefinition' --output text)

              # Only keep task definitions that match our family
              if [[ "$td" == *"$TASK_FAMILY"* ]]; then
                  ACTIVE_IN_USE+=("$td")
                  echo -e "üîé Active task definition ${YELLOW}$TASK_FAMILY${NC} in use by service ${GREEN}$svc${NC}"
              fi
          done

          # Remove duplicates and sort
          ACTIVE_IN_USE=($(printf "%s\n" "${ACTIVE_IN_USE[@]}" | sort -u))

          # Revisions to attempt deletion
          TO_DELETE=$(echo $REVISIONS | awk -v c=$DELETE_COUNT '{for(i=1;i<=c;i++) print $i}')
          KEPT=()

          echo "üóëÔ∏è Checking and deleting old task definition revisions..."
          for rev in $TO_DELETE; do
              if printf '%s\n' "${ACTIVE_IN_USE[@]}" | grep -qx "$rev"; then
                  echo -e "‚è≠Ô∏è Skipping ${YELLOW}$rev${NC} (still in use by one or more services)"
                  KEPT+=("$rev")
              else
                  echo -e "üóëÔ∏è Deleting ${YELLOW}$rev${NC}"
                  aws ecs deregister-task-definition --task-definition "$rev" \
                      --query 'taskDefinition.taskDefinitionArn' --output text >/dev/null
              fi
          done

          # Add the remaining last $KEEP_LAST revisions to KEPT
          REMAINING=$(echo $REVISIONS | awk -v c=$DELETE_COUNT '{for(i=c+1;i<=NF;i++) print $i}')
          for r in $REMAINING; do KEPT+=("$r"); done

          echo -e "‚úÖ Cleanup complete. Kept last $KEEP_LAST revisions, skipped active ones:"
          for r in "${KEPT[@]}"; do
              echo -e "   - ${YELLOW}$r${NC}"
          done